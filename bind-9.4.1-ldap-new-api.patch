--- bind-9.4.1/contrib/sdb/ldap/ldapdb.c.new-api	2004-08-27 02:10:25.000000000 +0200
+++ bind-9.4.1/contrib/sdb/ldap/ldapdb.c	2007-05-22 16:50:16.000000000 +0200
@@ -58,9 +58,13 @@
 static dns_sdbimplementation_t *ldapdb = NULL;
 
 struct ldapdb_data {
+#if LDAP_API_VERSION >= 3001
+	LDAPURLDesc *lud;
+#else
 	char *hostport;
 	char *hostname;
 	int portno;
+#endif
 	char *base;
 	int defaultttl;
 	char *filterall;
@@ -135,7 +139,11 @@ ldapdb_getconn(struct ldapdb_data *data)
 				conndata = threaddata->data;
 				free(conndata->index);
 				if (conndata->data != NULL)
+#if LDAP_API_VERSION < 3001
 					ldap_unbind((LDAP *)conndata->data);
+#else
+					ldap_unbind_ext((LDAP *)conndata->data, NULL, NULL);
+#endif
 				threaddata->data = conndata->next;
 				free(conndata);
 			}
@@ -172,14 +180,23 @@ ldapdb_getconn(struct ldapdb_data *data)
 	/* threaddata points at the connection list for current thread */
 	/* look for existing connection to our server */
 	conndata = ldapdb_find((struct ldapdb_entry *)threaddata->data,
-			       data->hostport, strlen(data->hostport));
+#if LDAP_API_VERSION < 3001
+				data->hostport, strlen(data->hostport));
+#else
+				data->lud->lud_host, strlen(data->lud->lud_host));
+#endif
 	if (conndata == NULL) {
 		/* no connection data structure for this server, create one */
 		conndata = malloc(sizeof(*conndata));
 		if (conndata == NULL)
 			return (NULL);
+#if LDAP_API_VERSION < 3001
 		conndata->index = data->hostport;
 		conndata->size = strlen(data->hostport);
+#else
+		conndata->index = data->lud->lud_host;
+		conndata->size = strlen(data->lud->lud_host);
+#endif
 		conndata->data = NULL;
 		ldapdb_insert((struct ldapdb_entry **)&threaddata->data,
 			      conndata);
@@ -196,9 +213,15 @@ ldapdb_bind(struct ldapdb_data *data, LD
 #endif
 
 	if (*ldp != NULL)
+#if LDAP_API_VERSION < 3001
 		ldap_unbind(*ldp);
 	*ldp = ldap_open(data->hostname, data->portno);
 	if (*ldp == NULL)
+#else
+		ldap_unbind_ext (*ldp, NULL, NULL);
+	int res = ldap_initialize(ldp, ldap_url_desc2str(data->lud));
+	if (res != LDAP_SUCCESS)
+#endif
 		return;
 
 #ifndef LDAPDB_RFC1823API
@@ -211,8 +234,17 @@ ldapdb_bind(struct ldapdb_data *data, LD
 	}
 #endif
 
+#if LDAP_API_VERSION < 3001
 	if (ldap_simple_bind_s(*ldp, data->bindname, data->bindpw) != LDAP_SUCCESS) {
 		ldap_unbind(*ldp);
+#else
+	struct berval ber;
+	ber.bv_val = data->bindpw;
+	ber.bv_len = (data->bindpw == NULL) ? 0 : strlen(data->bindpw);
+
+	if (ldap_sasl_bind_s(*ldp, data->base, LDAP_SASL_SIMPLE, &ber, NULL, NULL, NULL) != LDAP_SUCCESS) {
+		ldap_unbind_ext(*ldp, NULL, NULL);
+#endif
 		*ldp = NULL;
 	}
 }
@@ -224,14 +256,19 @@ ldapdb_search(const char *zone, const ch
 	isc_result_t result = ISC_R_NOTFOUND;
 	LDAP **ldp;
 	LDAPMessage *res, *e;
-	char *fltr, *a, **vals = NULL, **names = NULL;
+	char *fltr, *a;
+#if LDAP_API_VERSION < 3001
+	char **names, **vals;
+#else
+	struct berval **names, **vals;
+#endif
 	char type[64];
 #ifdef LDAPDB_RFC1823API
 	void *ptr;
 #else
 	BerElement *ptr;
 #endif
-	int i, j, errno, msgid;
+	int i, j, errno, msgid, ldap_res;
 
 	ldp = ldapdb_getconn(data);
 	if (ldp == NULL)
@@ -256,12 +293,21 @@ ldapdb_search(const char *zone, const ch
 		sprintf(data->filtername, "%s))", name);
 		fltr = data->filterone;
 	}
-
+#if LDAP_API_VERSION < 3001
 	msgid = ldap_search(*ldp, data->base, LDAP_SCOPE_SUBTREE, fltr, NULL, 0);
+#else
+	ldap_res = ldap_search_ext(*ldp, data->base, LDAP_SCOPE_SUBTREE, fltr, NULL, 0,
+				 NULL, NULL, NULL, 65535, &msgid);
+#endif
 	if (msgid == -1) {
 		ldapdb_bind(data, ldp);
 		if (*ldp != NULL)
+#if LDAP_API_VERSION < 3001
 			msgid = ldap_search(*ldp, data->base, LDAP_SCOPE_SUBTREE, fltr, NULL, 0);
+#else
+			ldap_res = ldap_search_ext(*ldp, data->base, LDAP_SCOPE_SUBTREE, fltr, NULL, 0,
+                                 NULL, NULL, NULL, 65535, &msgid);
+#endif
 	}
 
 	if (*ldp == NULL || msgid == -1) {
@@ -293,15 +339,27 @@ ldapdb_search(const char *zone, const ch
                 }
 
 		if (name == NULL) {
+#if LDAP_API_VERSION < 3001
 			names = ldap_get_values(ld, e, "relativeDomainName");
+#else
+			names = ldap_get_values_len(ld, e, "relativeDomainName");
+#endif
 			if (names == NULL)
 				continue;
 		}
-
+#if LDAP_API_VERSION < 3001
 		vals = ldap_get_values(ld, e, "dNSTTL");
+#else
+		vals = ldap_get_values_len(ld, e, "dNSTTL");
+#endif
 		if (vals != NULL) {
+#if LDAP_API_VERSION < 3001
 			ttl = atoi(vals[0]);
 			ldap_value_free(vals);
+#else
+			ttl = atoi(vals[0]->bv_val);
+			ldap_value_free_len(vals);
+#endif
 		}
 
 		for (a = ldap_first_attribute(ld, e, &ptr); a != NULL; a = ldap_next_attribute(ld, e, ptr)) {
@@ -319,34 +377,60 @@ ldapdb_search(const char *zone, const ch
 
 			strncpy(type, a, s - a);
 			type[s - a] = '\0';
+#if LDAP_API_VERSION < 3001
 			vals = ldap_get_values(ld, e, a);
+#else
+			vals = ldap_get_values_len(ld, e, a);
+#endif
 			if (vals != NULL) {
 				for (i = 0; vals[i] != NULL; i++) {
 					if (name != NULL) {
+#if LDAP_API_VERSION < 3001
 						result = dns_sdb_putrr(retdata, type, ttl, vals[i]);
+#else
+						result = dns_sdb_putrr(retdata, type, ttl, vals[i]->bv_val);
+#endif
 					} else {
 						for (j = 0; names[j] != NULL; j++) {
+#if LDAP_API_VERSION < 3001
 							result = dns_sdb_putnamedrr(retdata, names[j], type, ttl, vals[i]);
+#else
+							result = dns_sdb_putnamedrr(retdata, names[j]->bv_val, type, ttl, vals[i]->bv_val);
+#endif
 							if (result != ISC_R_SUCCESS)
 								break;
 						}
 					}
-;					if (result != ISC_R_SUCCESS) {
+					if (result != ISC_R_SUCCESS) {
+#if LDAP_API_VERSION < 3001
 						isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_SERVER, ISC_LOG_ERROR,	
 							      "LDAP sdb zone '%s': dns_sdb_put... failed for %s", zone, vals[i]);
 						ldap_value_free(vals);
+#else
+						isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_SERVER, ISC_LOG_ERROR,	
+							      "LDAP sdb zone '%s': dns_sdb_put... failed for %s", zone, vals[i]->bv_val);
+						ldap_value_free_len(vals);
+#endif
 #ifndef LDAPDB_RFC1823API
 						ldap_memfree(a);
 						if (ptr != NULL)
 							ber_free(ptr, 0);
 #endif
 						if (name == NULL)
+#if LDAP_API_VERSION < 3001
 							ldap_value_free(names);
+#else
+							ldap_value_free_len(names);
+#endif
 						ldap_msgfree(res);
 						return (ISC_R_FAILURE);
 					}
 				}
+#if LDAP_API_VERSION < 3001
 				ldap_value_free(vals);
+#else
+				ldap_value_free_len(vals);
+#endif
 			}
 #ifndef LDAPDB_RFC1823API
 			ldap_memfree(a);
@@ -357,7 +441,11 @@ ldapdb_search(const char *zone, const ch
 			ber_free(ptr, 0);
 #endif
 		if (name == NULL)
+#if LDAP_API_VERSION < 3001
 			ldap_value_free(names);
+#else
+			ldap_value_free_len(names);
+#endif
 
 		/* free this result */
 		ldap_msgfree(res);
@@ -460,10 +548,15 @@ parseextensions(char *extensions, struct
 static void
 free_data(struct ldapdb_data *data)
 {
+#if LDAP_API_VERSION < 3001
 	if (data->hostport != NULL)
 		isc_mem_free(ns_g_mctx, data->hostport);
 	if (data->hostname != NULL)
 		isc_mem_free(ns_g_mctx, data->hostname);
+#else
+	if (data->lud != NULL)
+		ldap_free_urldesc(data->lud);
+#endif
 	if (data->filterall != NULL)
 		isc_mem_put(ns_g_mctx, data->filterall, data->filteralllen);
 	if (data->filterone != NULL)
@@ -478,7 +571,7 @@ ldapdb_create(const char *zone, int argc
 {
 	struct ldapdb_data *data;
 	char *s, *filter = NULL, *extensions = NULL;
-	int defaultttl;
+	int defaultttl, i;
 
 	UNUSED(driverdata);
 
@@ -486,7 +579,10 @@ ldapdb_create(const char *zone, int argc
 	/* want to do this only once for all instances */
 
 	if ((argc < 2)
+#if LDAP_API_VERSION < 3001
+	/* Could be ldap[is]:// */
 	    || (argv[0] != strstr( argv[0], "ldap://"))
+#endif
 	    || ((defaultttl = atoi(argv[1])) < 1))
                 return (ISC_R_FAILURE);
         data = isc_mem_get(ns_g_mctx, sizeof(struct ldapdb_data));
@@ -494,14 +590,15 @@ ldapdb_create(const char *zone, int argc
                 return (ISC_R_NOMEMORY);
 
 	memset(data, 0, sizeof(struct ldapdb_data));
+
+	data->defaultttl = defaultttl;
+#if LDAP_API_VERSION < 3001
 	data->hostport = isc_mem_strdup(ns_g_mctx, argv[0] + strlen("ldap://"));
 	if (data->hostport == NULL) {
 		free_data(data);
 		return (ISC_R_NOMEMORY);
 	}
 
-	data->defaultttl = defaultttl;
-
 	s = strchr(data->hostport, '/');
 	if (s != NULL) {
 		*s++ = '\0';
@@ -544,11 +641,26 @@ ldapdb_create(const char *zone, int argc
 		}
 	}
 
+#else
+	if (ldap_url_parse (argv[0], &data->lud) != LDAP_URL_SUCCESS) {
+		free_data (data);
+		return (ISC_R_FAILURE);
+	}
+
+	data->base = data->lud->lud_dn;
+
+	for (i = 0; data->lud->lud_exts[i] != NULL; i++) {
+		extensions = strdup (data->lud->lud_exts[i]);
+#endif
+
 	/* parse extensions */
 	if (extensions != NULL) {
 		int err;
 
 		err = parseextensions(extensions, data);
+#if LDAP_API_VERSION >= 3001
+		free (extensions);
+#endif
 		if (err < 0) {
 			/* err should be -1 or -2 */
 			free_data(data);
@@ -562,6 +674,14 @@ ldapdb_create(const char *zone, int argc
 			return (ISC_R_FAILURE);
 		}
 	}
+#if LDAP_API_VERSION >= 3001
+	else {
+		free_data (data);
+		return (ISC_R_NOMEMORY);
+	}
+	}
+	filter = data->lud->lud_filter;
+#else
 
 	if ((data->base != NULL && unhex(data->base) == NULL) ||
 	    (filter != NULL && unhex(filter) == NULL) ||
@@ -572,6 +692,7 @@ ldapdb_create(const char *zone, int argc
 			      "LDAP sdb zone '%s': URL: bad hex values", zone);
 		return (ISC_R_FAILURE);
 	}
+#endif
 
 	/* compute filterall and filterone once and for all */
 	if (filter == NULL) {
@@ -602,6 +723,7 @@ ldapdb_create(const char *zone, int argc
 	}
 	data->filtername = data->filterone + strlen(data->filterone);
 
+#if LDAP_API_VERSION < 3001
 	/* support URLs with literal IPv6 addresses */
 	data->hostname = isc_mem_strdup(ns_g_mctx, data->hostport + (*data->hostport == '[' ? 1 : 0));
 	if (data->hostname == NULL) {
@@ -620,8 +742,10 @@ ldapdb_create(const char *zone, int argc
 		data->portno = atoi(s);
 	} else
 		data->portno = LDAP_PORT;
+#endif
 
 	*dbdata = data;
+
 	return (ISC_R_SUCCESS);
 }
 
