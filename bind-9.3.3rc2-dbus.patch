--- bind-9.4.0/lib/isc/include/isc/socket.h.dbus	2006-06-07 02:29:45.000000000 +0200
+++ bind-9.4.0/lib/isc/include/isc/socket.h	2007-03-06 13:58:11.000000000 +0100
@@ -135,6 +135,10 @@
 #define ISC_SOCKEVENT_NEWCONN	(ISC_EVENTCLASS_SOCKET + 3)
 #define ISC_SOCKEVENT_CONNECT	(ISC_EVENTCLASS_SOCKET + 4)
 
+#define ISC_SOCKEVENT_READ_READY  (ISC_EVENTCLASS_SOCKET + 5)
+#define ISC_SOCKEVENT_WRITE_READY (ISC_EVENTCLASS_SOCKET + 6)
+#define ISC_SOCKEVENT_SELECTED    (ISC_EVENTCLASS_SOCKET + 7)
+
 /*
  * Internal events.
  */
@@ -144,7 +148,8 @@
 typedef enum {
 	isc_sockettype_udp = 1,
 	isc_sockettype_tcp = 2,
-	isc_sockettype_unix = 3
+	isc_sockettype_unix = 3,
+	isc_sockettype_fd = 8
 } isc_sockettype_t;
 
 /*@{*/
@@ -747,6 +752,54 @@
  * \li	#ISC_R_FAILURE
  */
 
+isc_socketevent_t*
+isc_socket_fd_handle_reads( isc_socket_t *sock, isc_socketevent_t *dev );
+/* register the "dev" event to be sent when the isc_sockettype_fd sock 
+ * was select()-ed for read. If there is already an event registered, it
+ * is returned, otherwise 0 is returned. If dev is 0, removes any existing
+ * registered event.
+ */
+ 
+isc_socketevent_t*
+isc_socket_fd_handle_writes( isc_socket_t *sock, isc_socketevent_t *dev );
+/* register the "dev" event to be sent when the isc_sockettype_fd sock 
+ * was select()-ed for write. If there is already an event registered, it
+ * is returned, otherwise 0 is returned. If dev is 0, removes any existing
+ * registered event.
+ */
+
+isc_socketevent_t*
+isc_socket_fd_handle_selected( isc_socket_t *sock, isc_socketevent_t *dev );
+/* register the "dev" event to be sent when ALL isc_sockettype_fd sockets 
+ * have been select()-ed . If there is already an event registered, it
+ * is returned, otherwise 0 is returned. If dev is 0, removes any existing
+ * registered event.
+ */
+
+isc_socketevent_t*
+isc_socket_fd_handle_reads( isc_socket_t *sock, isc_socketevent_t *dev );
+/* register the "dev" event to be sent when the isc_sockettype_fd sock 
+ * was select()-ed for read. If there is already an event registered, it
+ * is returned, otherwise 0 is returned. If dev is 0, removes any existing
+ * registered event.
+ */
+ 
+isc_socketevent_t*
+isc_socket_fd_handle_writes( isc_socket_t *sock, isc_socketevent_t *dev );
+/* register the "dev" event to be sent when the isc_sockettype_fd sock 
+ * was select()-ed for write. If there is already an event registered, it
+ * is returned, otherwise 0 is returned. If dev is 0, removes any existing
+ * registered event.
+ */
+
+isc_socketevent_t*
+isc_socket_fd_handle_selected( isc_socket_t *sock, isc_socketevent_t *dev );
+/* register the "dev" event to be sent when ALL isc_sockettype_fd sockets 
+ * have been select()-ed . If there is already an event registered, it
+ * is returned, otherwise 0 is returned. If dev is 0, removes any existing
+ * registered event.
+ */
+
 ISC_LANG_ENDDECLS
 
 #endif /* ISC_SOCKET_H */
--- bind-9.4.0/lib/isc/unix/socket.c.dbus	2007-03-06 13:45:26.000000000 +0100
+++ bind-9.4.0/lib/isc/unix/socket.c	2007-03-06 13:45:26.000000000 +0100
@@ -159,6 +159,11 @@
 	ISC_LIST(isc_socketevent_t)		recv_list;
 	ISC_LIST(isc_socket_newconnev_t)	accept_list;
 	isc_socket_connev_t		       *connect_ev;
+        
+        /* these are used only by isc_sockettype_fd sockets:*/
+        isc_socketevent_t      *read_ready_event;
+        isc_socketevent_t      *write_ready_event;
+        isc_socketevent_t      *selected_event;
 
 	/*
 	 * Internal events.  Posted when a descriptor is readable or
@@ -315,7 +320,7 @@
 
 static void
 wakeup_socket(isc_socketmgr_t *manager, int fd, int msg) {
-	isc_socket_t *sock;
+	isc_socket_t *sock=0L;
 
 	/*
 	 * This is a wakeup on a socket.  If the socket is not in the
@@ -1311,6 +1316,9 @@
 	sock->connected = 0;
 	sock->connecting = 0;
 	sock->bound = 0;
+	sock->read_ready_event = 0L;
+	sock->write_ready_event = 0L;
+	sock->selected_event = 0L;
 
 	/*
 	 * initialize the lock
@@ -1426,13 +1434,16 @@
 	case isc_sockettype_unix:
 		sock->fd = socket(pf, SOCK_STREAM, 0);
 		break;
+
+	case isc_sockettype_fd:
+	        sock->fd = pf;
 	}
 
 #ifdef F_DUPFD
 	/*
 	 * Leave a space for stdio to work in.
 	 */
-	if (sock->fd >= 0 && sock->fd < 20) {
+	if ( (type != isc_sockettype_fd) && (sock->fd >= 0) && (sock->fd < 20) ) {
 		int new, tmp;
 		new = fcntl(sock->fd, F_DUPFD, 20);
 		tmp = errno;
@@ -1486,7 +1497,7 @@
 		}
 	}
 
-	if (make_nonblock(sock->fd) != ISC_R_SUCCESS) {
+	if ((type != isc_sockettype_fd) && (make_nonblock(sock->fd) != ISC_R_SUCCESS)) {
 		(void)close(sock->fd);
 		free_socket(&sock);
 		return (ISC_R_UNEXPECTED);
@@ -1777,6 +1788,38 @@
 	isc_task_send(ev->ev_sender, (isc_event_t **)&iev);
 }
 
+static
+isc_event_t *dispatch_read_ready(isc_socketmgr_t *manager, isc_socket_t *sock)
+{
+    isc_event_t *dev = (isc_event_t*)sock->read_ready_event, *ev;
+    
+    ev = isc_mem_get(manager->mctx, dev->ev_size);
+    memcpy(ev,dev,dev->ev_size);
+    ISC_LINK_INIT(ev,ev_link);
+    isc_task_send(dev->ev_sender, &ev );
+    return (isc_event_t *)sock->selected_event;
+}
+
+static
+isc_event_t *dispatch_write_ready(isc_socketmgr_t *manager,isc_socket_t *sock)
+{
+    isc_event_t *dev = (isc_event_t*)sock->write_ready_event, *ev;
+    ev = isc_mem_get(manager->mctx, dev->ev_size);
+    memcpy(ev,dev,dev->ev_size);
+    ISC_LINK_INIT(ev,ev_link);
+    isc_task_send(dev->ev_sender, &ev );
+    return (isc_event_t *)sock->selected_event;
+}
+
+static
+void dispatch_selected(isc_socketmgr_t *manager, isc_event_t *dev)
+{   isc_event_t *ev;
+    ev = isc_mem_get(manager->mctx, dev->ev_size);
+    memcpy(ev,dev,dev->ev_size);
+    ISC_LINK_INIT(ev,ev_link);
+    isc_task_send(dev->ev_sender, &ev );
+}
+
 /*
  * Dequeue an item off the given socket's read queue, set the result code
  * in the done event to the one provided, and send it to the task it was
@@ -2184,6 +2227,7 @@
 	int i;
 	isc_socket_t *sock;
 	isc_boolean_t unlock_sock;
+	isc_event_t *sock_selected = 0L;
 
 	REQUIRE(maxfd <= (int)FD_SETSIZE);
 
@@ -2217,11 +2261,15 @@
 			unlock_sock = ISC_TRUE;
 			LOCK(&sock->lock);
 			if (!SOCK_DEAD(sock)) {
+			    if( sock->type != isc_sockettype_fd )
+			    {
 				if (sock->listener)
 					dispatch_accept(sock);
 				else
 					dispatch_recv(sock);
-			}
+			    }else			    
+				sock_selected = dispatch_read_ready(manager,sock);
+			}			    
 			FD_CLR(i, &manager->read_fds);
 		}
 	check_write:
@@ -2235,16 +2283,24 @@
 				LOCK(&sock->lock);
 			}
 			if (!SOCK_DEAD(sock)) {
+			    if( sock->type != isc_sockettype_fd )
+			    {
 				if (sock->connecting)
 					dispatch_connect(sock);
 				else
 					dispatch_send(sock);
+			    }else			   
+				sock_selected =	dispatch_write_ready(manager,sock);
 			}
 			FD_CLR(i, &manager->write_fds);
 		}
 		if (unlock_sock)
 			UNLOCK(&sock->lock);
 	}
+	if( sock_selected != 0L )
+	{
+	    dispatch_selected(manager, sock_selected);
+	}
 }
 
 #ifdef ISC_PLATFORM_USETHREADS
@@ -2263,7 +2319,7 @@
 	int cc;
 	fd_set readfds;
 	fd_set writefds;
-	int msg, fd;
+	int msg, fd = -1;
 	int maxfd;
 	char strbuf[ISC_STRERRORSIZE];
 
@@ -3784,3 +3840,55 @@
 	return (ISC_R_SUCCESS);
 }
 #endif /* ISC_PLATFORM_USETHREADS */
+
+isc_socketevent_t*
+isc_socket_fd_handle_reads( isc_socket_t *sock, isc_socketevent_t *dev )
+{    
+    REQUIRE(VALID_SOCKET(sock));   
+    if(dev != 0L) 
+    {
+	sock->references=1;
+	sock->read_ready_event = dev;
+	select_poke(sock->manager, sock->fd, SELECT_POKE_READ);
+    }else
+    {
+	dev = sock->read_ready_event ;
+	sock->read_ready_event = 0L ;
+    }
+    return dev;
+}
+
+isc_socketevent_t*
+isc_socket_fd_handle_writes( isc_socket_t *sock, isc_socketevent_t *dev )
+{
+    REQUIRE(VALID_SOCKET(sock));   
+    if(dev != 0L) 
+    {
+	sock->references=1;
+	sock->write_ready_event = dev;
+	select_poke(sock->manager, sock->fd, SELECT_POKE_WRITE);    
+    }else
+    {
+	dev = sock->write_ready_event;
+	sock->write_ready_event = 0L;
+    }
+    return dev;
+}
+
+isc_socketevent_t*
+isc_socket_fd_handle_selected( isc_socket_t *sock, isc_socketevent_t *dev )
+{
+    REQUIRE(VALID_SOCKET(sock));
+    if(dev != 0L) 
+    {
+	sock->references=1;
+	sock->selected_event = dev;
+    }else
+    {
+	dev = sock->selected_event;
+	sock->selected_event = 0L;
+	sock->references=0;
+	destroy(&sock);
+    }
+    return dev;
+}
--- bind-9.4.0/lib/dns/forward.c.dbus	2005-07-12 03:22:20.000000000 +0200
+++ bind-9.4.0/lib/dns/forward.c	2007-03-06 13:45:26.000000000 +0100
@@ -197,3 +197,89 @@
 	}
 	isc_mem_put(fwdtable->mctx, forwarders, sizeof(dns_forwarders_t));
 }
+
+/***
+ *** new D-BUS Dynamic Forwarding Zones functions:
+ ***/
+isc_result_t
+dns_fwdtable_delete(dns_fwdtable_t *fwdtable, dns_name_t *name )
+{
+	isc_result_t result;
+
+	REQUIRE(VALID_FWDTABLE(fwdtable));
+
+	RWLOCK(&fwdtable->rwlock, isc_rwlocktype_write);
+
+	result = dns_rbt_deletename(fwdtable->table, name, ISC_FALSE);
+
+	RWUNLOCK(&fwdtable->rwlock, isc_rwlocktype_write);		    
+
+	return (result);
+}
+
+isc_result_t
+dns_fwdtable_find_closest(dns_fwdtable_t *fwdtable, 
+			  dns_name_t *name, 
+			  dns_name_t *foundname,
+			  dns_forwarders_t **forwardersp)
+{
+	isc_result_t result;
+
+	REQUIRE(VALID_FWDTABLE(fwdtable));
+	
+	RWLOCK(&fwdtable->rwlock, isc_rwlocktype_read);
+
+	result = dns_rbt_findname(fwdtable->table, name, 0, foundname,
+				  (void **)forwardersp);
+	
+	if(result == DNS_R_PARTIALMATCH)
+	    result = ISC_R_SUCCESS;
+
+	RWUNLOCK(&fwdtable->rwlock, isc_rwlocktype_read);
+
+	return (result);
+}
+
+isc_result_t
+dns_fwdtable_find_exact(dns_fwdtable_t *fwdtable, dns_name_t *name,
+		  dns_forwarders_t **forwardersp)
+{
+	isc_result_t result;
+
+	REQUIRE(VALID_FWDTABLE(fwdtable));
+
+	REQUIRE(forwardersp != 0L);
+
+	RWLOCK(&fwdtable->rwlock, isc_rwlocktype_read);
+
+	result = dns_rbt_findname(fwdtable->table, name, 0, NULL,
+				  (void **)forwardersp);
+	
+	if( result != ISC_R_SUCCESS )
+	    *forwardersp = 0L;
+
+	RWUNLOCK(&fwdtable->rwlock, isc_rwlocktype_read);
+
+	return (result);
+}
+
+static 
+void dns_fwdtable_traverse
+(   
+    dns_name_t *name,
+    void *node_data,
+    void *cbp,
+    void *cb_arg
+)
+{
+    dns_fwdtable_callback_t  cb = (dns_fwdtable_callback_t) cbp;
+    
+    (*cb)( name, node_data, cb_arg);
+}
+
+void dns_fwdtable_foreach(dns_fwdtable_t *fwdtable, dns_fwdtable_callback_t cb, void *cb_arg )
+{
+    REQUIRE(VALID_FWDTABLE(fwdtable));
+
+    dns_rbt_traverse( fwdtable->table, dns_fwdtable_traverse, cb, cb_arg );
+}
--- bind-9.4.0/lib/dns/rbt.c.dbus	2005-10-13 03:26:06.000000000 +0200
+++ bind-9.4.0/lib/dns/rbt.c	2007-03-06 13:45:26.000000000 +0100
@@ -2175,6 +2175,47 @@
 	dns_rbt_printtree(rbt->root, NULL, 0);
 }
 
+static void
+dns_rbt_traverse_tree(dns_rbtnode_t *root,  dns_rbt_traverse_callback_t cb, void *cb_arg1, void *cb_arg2 ) {
+/*
+ * This is used ONLY to traverse the forward table by dbus_mgr at the moment.
+ * Since the forward table is not likely to be large, this can be recursive.
+ */
+	dns_name_t name;
+	dns_offsets_t offsets;
+	char buf[DNS_NAME_MAXWIRE];
+	isc_buffer_t buffer;
+
+	if (root != NULL) {
+
+		if (DOWN(root)) 
+			dns_rbt_traverse_tree(DOWN(root), cb, cb_arg1, cb_arg2);
+
+		if( LEFT(root) != NULL )
+		        dns_rbt_traverse_tree(LEFT(root), cb, cb_arg1, cb_arg2);
+
+		if( RIGHT(root) != NULL )
+		        dns_rbt_traverse_tree(RIGHT(root), cb, cb_arg1, cb_arg2);
+
+		if( DATA(root) == 0L )
+		    return;
+
+		dns_name_init(&name, offsets);
+		isc_buffer_init(&buffer, buf, DNS_NAME_MAXWIRE);
+		dns_name_setbuffer( &name, &buffer);
+		dns_rbt_fullnamefromnode(root, &name);
+		
+		(*cb)(&name, DATA(root), cb_arg1, cb_arg2);		
+	} 
+}
+
+void dns_rbt_traverse( dns_rbt_t *rbt, dns_rbt_traverse_callback_t cb, void *cb_arg1, void *cb_arg2  )
+{
+        REQUIRE(VALID_RBT(rbt));
+
+	dns_rbt_traverse_tree( rbt->root, cb, cb_arg1, cb_arg2 );       
+}
+
 /*
  * Chain Functions
  */
--- bind-9.4.0/lib/dns/include/dns/rbt.h.dbus	2005-10-13 03:26:07.000000000 +0200
+++ bind-9.4.0/lib/dns/include/dns/rbt.h	2007-03-06 13:45:26.000000000 +0100
@@ -911,6 +911,17 @@
 	} while (0) 
 #endif /* DNS_RBT_USEISCREFCOUNT */
 
+
+typedef void (*dns_rbt_traverse_callback_t)(  dns_name_t *name,
+					      void *node_data,
+					      void *cb_arg1,
+					      void *cb_arg2);
+
+void dns_rbt_traverse( dns_rbt_t *rbt, dns_rbt_traverse_callback_t cb, void *cb_arg1, void *cb_arg2 );
+/* tree traversal function (only used by D-BUS dynamic forwarding dbus_mgr at
+ * the moment)
+ */
+
 ISC_LANG_ENDDECLS
 
 #endif /* DNS_RBT_H */
--- bind-9.4.0/lib/dns/include/dns/forward.h.dbus	2005-04-27 07:01:33.000000000 +0200
+++ bind-9.4.0/lib/dns/include/dns/forward.h	2007-03-06 13:45:26.000000000 +0100
@@ -113,6 +113,37 @@
  * \li	all memory associated with the forwarding table is freed.
  */
 
+
+/* These are ONLY used by dbus_mgr :
+ */
+
+isc_result_t
+dns_fwdtable_delete( dns_fwdtable_t *fwdtable, dns_name_t *name );
+/* 
+ * Removes an entry from the forwarding table.
+ */
+
+isc_result_t
+dns_fwdtable_find_exact(dns_fwdtable_t *fwdtable, dns_name_t *name,
+		  dns_forwarders_t **forwardersp);
+/*
+ * Finds an exact match for "name" in the forwarding table.  
+ */
+
+isc_result_t
+dns_fwdtable_find_closest(dns_fwdtable_t *fwdtable, dns_name_t *name, dns_name_t *foundname,
+		  dns_forwarders_t **forwardersp);
+/*
+ * Finds the closest match for "*name" in the forwarding table, returning  
+ * the actual name matching in *name if different to *name passed in. 
+ */
+
+typedef void (*dns_fwdtable_callback_t)( dns_name_t *, dns_forwarders_t *, void *);
+void dns_fwdtable_foreach(dns_fwdtable_t *fwdtable, dns_fwdtable_callback_t cb, void * );
+/* Invoke cb for each member of fwdtable 
+ */
+
+
 ISC_LANG_ENDDECLS
 
 #endif /* DNS_FORWARD_H */
--- bind-9.4.0/bin/named/main.c.dbus	2006-11-10 19:51:14.000000000 +0100
+++ bind-9.4.0/bin/named/main.c	2007-03-06 14:11:18.000000000 +0100
@@ -248,7 +248,8 @@
 		"usage: named [-4|-6] [-c conffile] [-d debuglevel] "
 		"[-f|-g] [-n number_of_cpus]\n"
 		"             [-p port] [-s] [-t chrootdir] [-u username]\n"
-		"             [-m {usage|trace|record|size|mctx}]\n");
+		"             [-m {usage|trace|record|size|mctx}]\n"
+		"	      [-D ]\n");
 }
 
 static void
@@ -356,7 +357,7 @@
 
 	isc_commandline_errprint = ISC_FALSE;
 	while ((ch = isc_commandline_parse(argc, argv,
-			           "46c:C:d:fgi:lm:n:N:p:P:st:u:vx:")) != -1) {
+			           "46c:C:d:fgi:lm:n:N:p:P:st:u:vx:D")) != -1) {
 		switch (ch) {
 		case '4':
 			if (disable4)
@@ -445,6 +446,9 @@
 		case 'v':
 			printf("BIND %s\n", ns_g_version);
 			exit(0);
+		case 'D':
+		        ns_g_dbus = 1;
+			break;
 		case '?':
 			usage();
 			ns_main_earlyfatal("unknown option '-%c'",
--- bind-9.4.0/bin/named/log.c.dbus	2006-06-09 02:54:08.000000000 +0200
+++ bind-9.4.0/bin/named/log.c	2007-03-06 13:45:26.000000000 +0100
@@ -44,6 +44,7 @@
 	{ "queries",	 		0 },
 	{ "unmatched",	 		0 },
 	{ "update-security",		0 },
+	{ "dbus",                       0 },
 	{ NULL, 			0 }
 };
 
@@ -63,6 +64,7 @@
 	{ "notify",	 		0 },
 	{ "control",	 		0 },
 	{ "lwresd",	 		0 },
+	{ "dbus",                       0 },
 	{ NULL, 			0 }
 };
 
--- bind-9.4.0/bin/named/include/named/server.h.dbus	2006-03-10 00:46:20.000000000 +0100
+++ bind-9.4.0/bin/named/include/named/server.h	2007-03-06 14:12:02.000000000 +0100
@@ -97,6 +97,8 @@
 	ns_dispatchlist_t	dispatches;
 
 	dns_acache_t		*acache;
+
+	ns_dbus_mgr_t *         dbus_mgr;
 };
 
 #define NS_SERVER_MAGIC			ISC_MAGIC('S','V','E','R')
--- bind-9.4.0/bin/named/include/named/types.h.dbus	2005-04-29 02:15:38.000000000 +0200
+++ bind-9.4.0/bin/named/include/named/types.h	2007-03-06 13:45:26.000000000 +0100
@@ -40,4 +40,6 @@
 typedef struct ns_dispatch		ns_dispatch_t;
 typedef ISC_LIST(ns_dispatch_t)		ns_dispatchlist_t;
 
+typedef struct ns_dbus_mgr              ns_dbus_mgr_t ;
+
 #endif /* NAMED_TYPES_H */
--- bind-9.4.0/bin/named/include/named/globals.h.dbus	2007-03-06 13:45:26.000000000 +0100
+++ bind-9.4.0/bin/named/include/named/globals.h	2007-03-06 13:45:26.000000000 +0100
@@ -114,6 +114,8 @@
 
 EXTERN int			ns_g_listen		INIT(3);
 
+EXTERN int                      ns_g_dbus               INIT(0);
+
 #undef EXTERN
 #undef INIT
 
--- bind-9.4.0/bin/named/include/named/log.h.dbus	2005-04-29 02:15:35.000000000 +0200
+++ bind-9.4.0/bin/named/include/named/log.h	2007-03-06 13:45:26.000000000 +0100
@@ -36,6 +36,7 @@
 #define NS_LOGCATEGORY_QUERIES		(&ns_g_categories[4])
 #define NS_LOGCATEGORY_UNMATCHED	(&ns_g_categories[5])
 #define NS_LOGCATEGORY_UPDATE_SECURITY	(&ns_g_categories[6])
+#define NS_LOGCATEGORY_DBUS      	(&ns_g_categories[7])
 
 /*
  * Backwards compatibility.
@@ -53,6 +54,7 @@
 #define NS_LOGMODULE_NOTIFY		(&ns_g_modules[8])
 #define NS_LOGMODULE_CONTROL		(&ns_g_modules[9])
 #define NS_LOGMODULE_LWRESD		(&ns_g_modules[10])
+#define NS_LOGMODULE_DBUS		(&ns_g_modules[11])
 
 isc_result_t
 ns_log_init(isc_boolean_t safe);
--- bind-9.4.0/bin/named/server.c.dbus	2006-12-07 06:24:19.000000000 +0100
+++ bind-9.4.0/bin/named/server.c	2007-03-06 13:45:26.000000000 +0100
@@ -167,6 +167,8 @@
 	ISC_LINK(struct zonelistentry)	link;
 };
 
+#include <named/dbus_mgr.h>
+
 /*
  * These zones should not leak onto the Internet.
  */
@@ -1985,12 +1987,12 @@
 	if (result != ISC_R_SUCCESS) {
 		char namebuf[DNS_NAME_FORMATSIZE];
 		dns_name_format(origin, namebuf, sizeof(namebuf));
-		cfg_obj_log(forwarders, ns_g_lctx, ISC_LOG_WARNING,
-			    "could not set up forwarding for domain '%s': %s",
+		cfg_obj_log(forwarders, ns_g_lctx, ISC_LOG_NOTICE,
+			    "setting up forwarding failed for domain '%s': %s",
 			    namebuf, isc_result_totext(result));
 		goto cleanup;
 	}
-
+		
 	result = ISC_R_SUCCESS;
 
  cleanup:
@@ -3418,6 +3420,20 @@
 
 	CHECKFATAL(load_zones(server, ISC_FALSE), "loading zones");
 
+	server->dbus_mgr = 0L;
+	if( ns_g_dbus )	
+	    if( dbus_mgr_create
+	        (  ns_g_mctx, ns_g_taskmgr, ns_g_socketmgr, ns_g_timermgr,
+		   &server->dbus_mgr
+		) != ISC_R_SUCCESS
+	      )
+	    {
+		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
+			      NS_LOGMODULE_SERVER, ISC_LOG_WARNING,
+			      "dbus_mgr initialization failed. D-BUS service is disabled."
+		             );
+	    }
+
 	ns_os_started();
 	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_SERVER,
 		      ISC_LOG_NOTICE, "running");
@@ -3481,6 +3497,9 @@
 
 	dns_db_detach(&server->in_roothints);
 
+	if( server->dbus_mgr != 0L )
+	    dbus_mgr_shutdown(server->dbus_mgr);
+
 	isc_task_endexclusive(server->task);
 
 	isc_task_detach(&server->task);
--- bind-9.4.0/bin/named/Makefile.in.dbus	2007-03-06 13:45:26.000000000 +0100
+++ bind-9.4.0/bin/named/Makefile.in	2007-03-06 14:08:10.000000000 +0100
@@ -43,6 +43,9 @@
 		${ISCCFG_INCLUDES} ${ISCCC_INCLUDES} ${ISC_INCLUDES} \
 		${DLZDRIVER_INCLUDES} ${DBDRIVER_INCLUDES}
 
+DBUS_INCLUDES = \
+        -I/usr/lib/dbus-1.0/include -I/usr/include/dbus-1.0
+
 CDEFINES =      @USE_DLZ@
 
 CWARNINGS =
@@ -60,6 +63,7 @@
 ISCDEPLIBS =	../../lib/isc/libisc.@A@
 LWRESDEPLIBS =	../../lib/lwres/liblwres.@A@
 BIND9DEPLIBS =	../../lib/bind9/libbind9.@A@
+DBUSLIBS=       -ldbus-1
 
 DEPLIBS =	${LWRESDEPLIBS} ${DNSDEPLIBS} ${BIND9DEPLIBS} \
 		${ISCCFGDEPLIBS} ${ISCCCDEPLIBS} ${ISCDEPLIBS}
@@ -80,6 +84,7 @@
 		zoneconf.o \
 		lwaddr.o lwresd.o lwdclient.o lwderror.o lwdgabn.o \
 		lwdgnba.o lwdgrbn.o lwdnoop.o lwsearch.o \
+		dbus_service.o dbus_mgr.o \
 		${DLZDRIVER_OBJS} ${DBDRIVER_OBJS}
 
 UOBJS =		unix/os.o
@@ -92,6 +97,7 @@
 		zoneconf.c \
 		lwaddr.c lwresd.c lwdclient.c lwderror.c lwdgabn.c \
 		lwdgnba.c lwdgrbn.c lwdnoop.c lwsearch.c \
+		dbus_service.c dbus_mgr.c \
 		${DLZDRIVER_SRCS} ${DBDRIVER_SRCS}
 
 MANPAGES =	named.8 lwresd.8 named.conf.5
@@ -120,9 +126,14 @@
 		-DNS_LOCALSTATEDIR=\"${localstatedir}\" \
 		-c ${srcdir}/config.c
 
+dbus_service.o: dbus_service.c
+	${LIBTOOL_MODE_COMPILE} ${CC} ${ALL_CFLAGS} \
+	        ${DBUS_INCLUDES} \
+		-c ${srcdir}/dbus_service.c
+
 named@EXEEXT@: ${OBJS} ${UOBJS} ${DEPLIBS}
 	${LIBTOOL_MODE_LINK} ${PURIFY} ${CC} ${CFLAGS} ${LDFLAGS} -o $@ \
-	${OBJS} ${UOBJS} ${LIBS}
+	${OBJS} ${UOBJS} ${LIBS} ${DBUSLIBS}
 
 lwresd@EXEEXT@: named@EXEEXT@
 	rm -f lwresd@EXEEXT@
--- bind-9.4.0/bin/named/named.8.dbus	2007-01-30 01:23:44.000000000 +0100
+++ bind-9.4.0/bin/named/named.8	2007-03-06 13:45:26.000000000 +0100
@@ -33,7 +33,7 @@
 named \- Internet domain name server
 .SH "SYNOPSIS"
 .HP 6
-\fBnamed\fR [\fB\-4\fR] [\fB\-6\fR] [\fB\-c\ \fR\fB\fIconfig\-file\fR\fR] [\fB\-d\ \fR\fB\fIdebug\-level\fR\fR] [\fB\-f\fR] [\fB\-g\fR] [\fB\-n\ \fR\fB\fI#cpus\fR\fR] [\fB\-p\ \fR\fB\fIport\fR\fR] [\fB\-s\fR] [\fB\-t\ \fR\fB\fIdirectory\fR\fR] [\fB\-u\ \fR\fB\fIuser\fR\fR] [\fB\-v\fR] [\fB\-x\ \fR\fB\fIcache\-file\fR\fR]
+\fBnamed\fR [\fB\-4\fR] [\fB\-6\fR] [\fB\-c\ \fR\fB\fIconfig\-file\fR\fR] [\fB\-d\ \fR\fB\fIdebug\-level\fR\fR] [\fB\-f\fR] [\fB\-g\fR] [\fB\-n\ \fR\fB\fI#cpus\fR\fR] [\fB\-p\ \fR\fB\fIport\fR\fR] [\fB\-s\fR] [\fB\-t\ \fR\fB\fIdirectory\fR\fR] [\fB\-u\ \fR\fB\fIuser\fR\fR] [\fB\-v\fR] [\fB\-x\ \fR\fB\fIcache\-file\fR\fR] [\fB\-D\fR]
 .SH "DESCRIPTION"
 .PP
 \fBnamed\fR
@@ -172,6 +172,13 @@
 This option must not be used. It is only of interest to BIND 9 developers and may be removed or changed in a future release.
 .RE
 .RE
+.sp
+.TP
+\fB\-D\fR
+Enable dynamic management of the forwarding table with D-BUS
+messages. This option is required for Red Hat NetworkManager
+support. See doc/README.DBUS .
+.sp
 .SH "SIGNALS"
 .PP
 In routine operation, signals should not be used to control the nameserver;
