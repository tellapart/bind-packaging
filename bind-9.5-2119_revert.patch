diff -up bind-9.5.0a6/lib/bind/resolv/res_init.c.2119 bind-9.5.0a6/lib/bind/resolv/res_init.c
--- bind-9.5.0a6/lib/bind/resolv/res_init.c.2119	2007-07-09 03:43:23.000000000 +0200
+++ bind-9.5.0a6/lib/bind/resolv/res_init.c	2007-09-03 10:10:24.000000000 +0200
@@ -166,9 +166,7 @@ __res_vinit(res_state statp, int preinit
 #endif
 	int dots;
 	union res_sockaddr_union u[2];
-	int maxns = MAXNS;
 
-	RES_SET_H_ERRNO(statp, 0);
 	if (statp->_u._ext.ext != NULL)
 		res_ndestroy(statp);
 
@@ -218,22 +216,8 @@ __res_vinit(res_state statp, int preinit
 		statp->_u._ext.ext->nsaddrs[0].sin = statp->nsaddr;
 		strcpy(statp->_u._ext.ext->nsuffix, "ip6.arpa");
 		strcpy(statp->_u._ext.ext->nsuffix2, "ip6.int");
-	} else {
-		/*
-		 * Historically res_init() rarely, if at all, failed.
-		 * Examples and applications exist which do not check
-		 * our return code.  Furthermore several applications
-		 * simply call us to get the systems domainname.  So
-		 * rather then immediately fail here we store the
-		 * failure, which is returned later, in h_errno.  And
-		 * prevent the collection of 'nameserver' information
-		 * by setting maxns to 0.  Thus applications that fail
-		 * to check our return code wont be able to make
-		 * queries anyhow.
-		 */
-		RES_SET_H_ERRNO(statp, NETDB_INTERNAL);
-		maxns = 0;
-	}
+	} else
+		return (-1);
 #ifdef RESOLVSORT
 	statp->nsort = 0;
 #endif
@@ -362,7 +346,7 @@ __res_vinit(res_state statp, int preinit
 		    continue;
 		}
 		/* read nameservers to query */
-		if (MATCH(buf, "nameserver") && nserv < maxns) {
+		if (MATCH(buf, "nameserver") && nserv < MAXNS) {
 		    struct addrinfo hints, *ai;
 		    char sbuf[NI_MAXSERV];
 		    const size_t minsiz =
@@ -498,7 +482,7 @@ __res_vinit(res_state statp, int preinit
 	if ((cp = getenv("RES_OPTIONS")) != NULL)
 		res_setoptions(statp, cp, "env");
 	statp->options |= RES_INIT;
-	return (statp->res_h_errno);
+	return (0);
 }
 
 static void
